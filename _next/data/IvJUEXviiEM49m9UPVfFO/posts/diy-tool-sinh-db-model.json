{"pageProps":{"postData":{"id":"diy-tool-sinh-db-model","contentHtml":"<p>Để giúp dev làm việc với DB dễ dàng hơn, hầu hết trong các ngôn ngữ bạn sẽ tìm thấy các thư viện ORM hay còn gọi là Object Relation Mapping. Đại loại là thư viện giúp bạn mapping biến trong ngôn ngữ lập trình với column trong DB dễ dàng và ít lỗi hơn.</p>\n<p>Ví dụ như trong Java có Hibernate, PHP có eloquent, Python thì có SQLAlchemy.</p>\n<p>Hầu hết các lib này sẽ bắt bạn phải cung cấp model class để định nghĩa table.\nVí dụ như class dưới đây trong SQLAlchemy</p>\n<pre><code class=\"language-python\">class Users(Base, PgModelsHelper):\n    __tablename__ = \"tbl_users\"\n    \n    first_name = Column(Text, nullable=False)\n    username = Column(Text, nullable=False)\n    last_name = Column(Text, nullable=False)\n    status = Column(BIGINT, nullable=False)\n    email = Column(Text, nullable=False)\n    password = Column(Text, nullable=False)\n    password_expires = Column(TIMESTAMP, nullable=False)\n    user_role_sysid = Column(BIGINT, nullable=False)\n\n    user_roles = relationship(\"UserRoles\", back_populates=\"users_list\")\n    __table_args__ = (\n        ForeignKeyConstraint([\"user_role_sysid\"], [\"tbl_user_roles.sysid\"]),\n    )\n</code></pre>\n<p>Tên column, kiểu data, tên khóa ... trong class cần mapping chính xác với thông tin table trong DB.\nVới một dự án cỡ trung bình thì sẽ có khoảng 30 ~ 60 tables, cơ lớn thì lên đến hàng trăm.</p>\n<p>Không biết các bạn thấy thế nào, chứ với mình, công việc viết các class này là công việc máy móc, nhàm chán và dễ sai sót. Hơn nữa mỗi khi DB thay đổi thì lại phải viết lại.\nNhiều lúc chỉ muốn có một cái tool nào đó nó tự viết cho mình được file này.\nThế thì tự DIY lấy 1 cái thôi, mình là người có khả năng mà :)))</p>\n<p>Tool DIY mình tạo trong repo dưới đây\n<a href=\"https://github.com/datlt/simple-alchemy-model-generator\">https://github.com/datlt/simple-alchemy-model-generator</a></p>\n<h2>Lấy thông tin cần thiết từ DB</h2>\n<p>Hầu hết project gần đây mình sử dụng PostgreSQL, khá là may mắn vì Postgre hỗ trợ truy cập thông tin table khá dễ và trực quan. Với các DB khác chắc chắn cũng có cách làm tương tự</p>\n<pre><code class=\"language-sql\">select json_build_object(\n\t'table_name', tab.table_name,\n    'columns', tab._col ,\n    'one_to_many', one_to_many._fk,\n    'many_to_one', many_to_one._fk,\n    'primary_key', pk_.column_name\n)as table_info from (\n\tselect \n\t\tcol.table_name as table_name , \n\t\tjson_agg(col) as _col\n\tfrom information_schema.\"columns\" col  \n\twhere col.table_schema = 'public' group by col.table_name\n) as tab\nleft outer join (\n\tselect one_to_many.table_name as table_name , json_agg(one_to_many) as _fk \n\tfrom\n\t(SELECT\n\t    tc.table_schema as table_schema , \n\t    tc.constraint_name as constraint_name , \n\t    tc.table_name as table_name , \n\t    kcu.column_name, \n\t    ccu.table_schema AS foreign_table_schema,\n\t    ccu.table_name AS foreign_table_name,\n\t    ccu.column_name AS foreign_column_name \n\tFROM \n\t    information_schema.table_constraints AS tc \n\t    JOIN information_schema.key_column_usage AS kcu\n\t      ON tc.constraint_name = kcu.constraint_name\n\t      AND tc.table_schema = kcu.table_schema\n\t    JOIN information_schema.constraint_column_usage AS ccu\n\t      ON ccu.constraint_name = tc.constraint_name\n\t      AND ccu.table_schema = tc.table_schema\n\tWHERE tc.constraint_type = 'FOREIGN KEY') as one_to_many\n\tgroup by one_to_many.table_name\n) as one_to_many on (one_to_many.table_name = tab.table_name)\nleft outer join (\n\tselect many_to_one.foreign_table_name as table_name , json_agg(many_to_one) as _fk \n\tfrom\n\t(SELECT\n\t    tc.table_schema as table_schema , \n\t    tc.constraint_name as constraint_name , \n\t    tc.table_name as table_name , \n\t    kcu.column_name, \n\t    ccu.table_schema AS foreign_table_schema,\n\t    ccu.table_name AS foreign_table_name,\n\t    ccu.column_name AS foreign_column_name \n\tFROM \n\t    information_schema.table_constraints AS tc \n\t    JOIN information_schema.key_column_usage AS kcu\n\t      ON tc.constraint_name = kcu.constraint_name\n\t      AND tc.table_schema = kcu.table_schema\n\t    JOIN information_schema.constraint_column_usage AS ccu\n\t      ON ccu.constraint_name = tc.constraint_name\n\t      AND ccu.table_schema = tc.table_schema\n\tWHERE tc.constraint_type = 'FOREIGN KEY') as many_to_one\n\tgroup by many_to_one.foreign_table_name\n) as many_to_one on (many_to_one.table_name = tab.table_name)\nleft outer join (\n\tselect tc.table_schema as table_schema , \n\t\ttc.table_name as table_name , \n\t\tkcu.column_name as column_name\n\tfrom information_schema.table_constraints as tc \n\tjoin information_schema.key_column_usage as kcu\n\tON tc.constraint_name = kcu.constraint_name\n\tAND tc.table_schema = kcu.table_schema\n\twhere tc.table_schema = 'public' and tc.constraint_type ='PRIMARY KEY'\n)as pk_ on (pk_.table_name = tab.table_name);\n</code></pre>\n<p>Tiếp theo là viết code để từ thông tin trong DB generate ra file model. Hầu hết ngôn ngữ đều có thư viện String template để lựa chọn.\nTrong python mình sử dụng Jinja2.\nKhi đó việc tạo file model quy thành bài toán viết template, nếu bạn đã quen với template của các ngôn ngữ như java, node, hay php thì việc này chắc chắn là không khó.</p>\n<p>Bạn có thể tham khảo template cho Jinja của mình trong repo.</p>\n<h2>Kết Luận</h2>\n<p>Paste lại link repo ví dụ của mình\n<a href=\"https://github.com/datlt/simple-alchemy-model-generator\">https://github.com/datlt/simple-alchemy-model-generator</a></p>\n<p>Như các bạn thấy, code không hề dài hay khó như mọi người vẫn nghĩ.\nBạn có thể dùng nó làm ví dụ hoặc code base để tùy biến theo nhu cầu.\nMột vài gợi ý để tùy biến:\nTự động sinh GraphQL schema theo thông tin DB\nTự động sinh File excel định nghĩa DB (Công việc này theo mình cũng là việc nhàm chán, máy móc và dễ lỗi :)))</p>\n<p>Chúc các bạn thành công</p>\n","title":"Tự DIY tool generate Model từ DB","date":"2021-06-02"}},"__N_SSG":true}